#include "STC15W4K.H" 
#include <string.h>	  
/******************************************************************
功能：将一个32位长整型变量dat转为字符串，比如把1234转为"1234"
参数：dat:待转的long型的变量
      str:指向字符数组的指针，转换后的字节串放在其中    
返回：转换后的字符串长度			        
 ******************************************************************/ 
unsigned char Long_Str(long dat,unsigned char *str) // 长整型数转换为字符串，返回值为转换后的字符串长度
{
	signed char i=0;
	unsigned char len = 0;
	unsigned char buf[11];	   // 长整数最大值4294967295，转ASCII码后占用10+1=11字节 
	if (dat < 0)               // 如果为负数，首先取绝对值，并添加负号
	{
		dat = -dat;
		*str++ = '-';
		len++;
	}
	do 
	{                               // 低位在前高位在后顺序排列
		buf[i++] = dat % 10+0x30;	// C语言中数组下标固定从0开始
		dat /= 10;
	} while (dat > 0);
    len += i;                 // i最后的值就是有效字符的个数
    while (i-- > 0)           // 高位在前低位在后顺序排列
    {
        *str++ = buf[i] ;
    }     
	*str = 0;                 // 添加字符串结束符方便使用KEIL自带的字符串处理函数处理
	return len;               // 返回字符串长度
}

/******************************************************************
功能：将一个字符串转为32位长整型变量，比如"1234"转为1234
参数：str:指向待转换的字符串           
返回：转换后的数值										       
 ******************************************** **********************/ 
/*
unsigned long Str_Long(char *str) 
{
	 unsigned long temp=0;
	 unsigned long fact=1;
	 unsigned char len=strlen(str);	// <string.h>头文件包含strlen()函数	
	 unsigned char i;		// strlen()函数计算的字符串长度不包含最后一个空字符(值0)
	 for(i=len;i>0;i--)															   
	 {
		temp+=((str[i-1]-0x30)*fact);  // 数组下标从0开始
		fact*=10;
	 }
	 return temp;
}
*/

/**************************************************************************
功能：STC15单片机串口1初始化,使用T1方式2自重载方式做波特率发生器 
 **************************************************************************/
void UART_Init(void)
{		 

//							PCON &= 0x7F;		//??????
//	SCON = 0x50;		//8???,?????
//	AUXR &= 0xBF;		//???1???Fosc/12,?12T
//	AUXR &= 0xFE;		//??1?????1???????
//	TMOD &= 0x0F;		//?????1???
//	TMOD |= 0x20;		//?????1?8???????
//	TL1 = 0xFD;		//??????
//	TH1 = 0xFD;		//????????
//	ET1 = 0;		//?????1??
//	TR1 = 1;		//?????1	
	// 下面代码设置定时器1
	TMOD |= 0x20;	// 0010 0000 定时器1工作于方式2（8位自动重装方式）
	TH1  = 0xFA;	// 波特率：9600 /22.1184MHZ
	TL1  = 0xFA;	// 波特率：9600 /22.1184MHZ
	TR1  = 1;
	// 下面代码设置定串口
	AUXR = 0x00;             // 很关键，使用定时器1作为波特率发生器，S1ST2=0
	SCON = 0x50; 	// 01010 0000 SM0.SM1=01(最普遍的8位通信）,REN=1（允许接受）
	// 下面代码设置中断
	ES   = 1;		// 关键：开启了中断就必须编写相应的中断函数，哪怕是中断空函数，
	                // 但必须有,否则程序进入中断入口地址后（这里是0023H)不能跳出，必然出错
	EA   = 1;
}  

/**************************************************************************
功能：STC15单片机的串口发送字节的函数
参数：dat:要发送的一个字节   
**************************************************************************/
void UART_Send_Byte(unsigned char dat)
{
	ES=0;		 // 使用查询发送结束方式，禁止中断干预
	SBUF = dat;
	while(!TI);	    
 	TI=0;	 //此句可以不要，不影响后面数据的发送，只供代码查询数据是否发送完成
	ES=1;
}	
/**************************************************************************
功能：STC15单片机的串口发送0d 0a ，即回车换行 
注：此函数就是发送0d 0a这两个字节，在"串口助手"上会有回车换行的效果
 **************************************************************************/  
void UART_Send_Enter()
{
	UART_Send_Byte(0x0d); // 转义字符常量\r，ASCII码值（10进制）=13，光标移到本行行首
	UART_Send_Byte(0x0a); // 转义字符常量\n，ASCII码值（10进制）=10，光标移到下行行首
}

/*
void UART_Send_Str(char *buf)
{
	while (*buf != '\0')   //说明：C语言字符串数组结尾必然有一个"\0"字符，在内存中数值为0
	{
		UART_send_byte(*buf++);	 //说明：* 和 ++优先级相同，结合性从右到左，但是++运
	}							 //算符有个特性就是先让变量参与运算，后进行加1操作
}	 */

/**************************************************************************
功能：51单片机的串口发送字符串  
参数：s:指向字符串的指针	  
注：如果在字符串中有'\n'，则会发送一个回车换行
 **************************************************************************/
void UART_Send_Str(char *s)
{
	unsigned int i; 	
	unsigned int len=strlen(s)-1;		// 最后一个字符单独处理
	for(i=0;i<len;i++) 
		UART_Send_Byte(s[i]);		// 	while (*buf != '\0')  UART_Send_Byte(*s++);
	if(s[i]=='\n') 			     
	{
		UART_Send_Enter();
	}
	else
	{
		UART_Send_Byte(s[i]);	// 普通字符正常发送
	}
}
/**************************************************************************
功能：51单片机的串口发送数值
参数：dat:要发送的数值(长整数)
  注：函数中会将数值转为相应的字符串，发送出去。比如 4567 转为 "4567" 
 **************************************************************************/
void UART_Send_Num(unsigned long dat)
{
	unsigned char temp[11];		// 长整数最大值4294967295，转ASCII码后占用10字节
	    //	由于后面程序要使用strlen()库函数计算长度，需增加1个字节存放结束符0
	Long_Str(dat,temp);	  
	UART_Send_Str(temp);
	UART_Send_Enter();          // 发送回车 
}
/**************************************************************************
功能：51单片机的串口发送调试信息（字符串+数值）	  
参数：inf:指向提示信息字符串的指针
      dat:一个数值，前面的提示信息就是在说明这个数值的意义
 **************************************************************************/
void UART_Send_StrNum(char *inf,unsigned long dat)
{
	UART_Send_Str(inf);
	UART_Send_Num(dat);	
} 

/**************************************************************************
功能：16进制转ASCII码函数
 **************************************************************************/
/*
unsigned char Hex_ASCII(unsigned int hex,char *str)
{
	unsigned char temp=0;
	
	temp=((hex&0xf000)>>12);	  // 4位1表示范围0_9_A_F
	str[0]=(temp>=10)?(temp-10+'A'):(temp+0x30);
		// 0_9的ASCII码是0_9+ 0x30，
	    // A_F的ASCII码: A代表数值10，A的ASCII码是65，因此数值+55=ASCII
		// 因此算式(temp-10+'A')=(temp-10+65)=(temp+55)
		// 分析依据：ASCII码表
	temp=((hex&0x0f00)>>8);
	str[1]=(temp>=10)?(temp-10+'A'):(temp+0x30);
	
	temp=((hex&0x00f0)>>4);
	str[2]=(temp>=10)?(temp-10+'A'):(temp+0x30);
	
	temp=((hex&0x000f)>>0);
	str[3]=(temp>=10)?(temp-10+'A'):(temp+0x30);
	
	str[4]=0;	    // 由于要使用KEIL自带的字符串处理函数处理，必须有结束标记。 
	
	return 0;
} 
*/
/**************************************************************************
功能：51单片机的串口输出ASCII码函数（接收端按字符形式接收则显示为HEX格式	）
 **************************************************************************/
/*
void UART_Send_Hex(unsigned int hex)
{
	unsigned char temp[11];
	Hex_ASCII(hex,temp);
	UART_Send_Str(temp);
	UART_Send_Enter();          // 发送回车
}
*/

/**************************************************************************
功能：51单片机的串口发送调试信息（二进制数据显示）	  
参数：dat:需要按2进制形式显示变量
 **************************************************************************/
/*
void UART_Send_binary(unsigned char dat)
{
	unsigned char i;
	unsigned char a[17];
	for(i=0;i<8;i++)
	{
		a[i]=((dat<<i)&0x80)?'1':'0';
	}
	a[i]=0;
	for(i=0;i<strlen(a);i++)
	{
		UART_Send_Byte(a[i]);
		UART_Send_Byte(' ');
	}
	UART_Send_Enter();          // 发送回车
}
*/
/**************************************************************************
功能：51单片机的串口1中断处理函数	
 **************************************************************************/
/*
void UART1_ISR (void) interrupt 4  // 串行口1中断函数  
{ ; }
*/

